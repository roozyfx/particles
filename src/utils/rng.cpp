#include <random>
#include <type_traits>

#include "sim/linear_algebra.h"
#include "utils/rng.h"

template <typename T>
vector<T> RNG<T>::GenerateUniformRandom(const size_t n, const T& low,
                                        const T& high) {
  vector<T> res;
  res.reserve(n);
  // Will be used to obtain a seed for the random number engine
  std::random_device rd;
  // Standard mersenne_twister_engine seeded with rd()
  std::mt19937 gen{rd()};

  if constexpr (!std::is_floating_point_v<T>) {  // Vec3d/Point3d
    const size_t N{3};
    // check if the low-high range is correct
    for (size_t i = 0; i < N; ++i)
      if (low[i] >= high[i]) return {};

    vector<uniform_real_distribution<decltype(low[0])>> dis(N);
    for (size_t i = 0; i < N; ++i)
      dis[i] = uniform_real_distribution<decltype(low[0])>(low[i], high[i]);

    for (size_t i = 0; i < n; ++i) {
      // Use disX to transform the random unsigned int generated by gen into a
      // DType
      res.emplace_back(T(dis[0](gen), dis[1](gen), dis[2](gen)));
    }

  } else {  // DType (double/float)
    if (low >= high) return {T(0)};

    uniform_real_distribution<T> dis(low, high);
    for (size_t i = 0; i < n; ++i) {
      res.emplace_back(dis(gen));
    }
  }

  return res;
}

template <typename T>
void RNG<T>::GenerateUniformRandom(T* data, const size_t n, const T& low,
                                   const T& high)
  requires std::floating_point<T>
{
  // check if the low-high range is correct
  if (!(low < high)) return;
  // Will be used to obtain a seed for the random number engine
  std::random_device rd;
  // Standard mersenne_twister_engine seeded with rd()
  std::mt19937 gen{rd()};

  uniform_real_distribution<T> dis(low, high);
  for (size_t i = 0; i < n; ++i) {
    // Use disX to transform the random unsigned
    // int generated by gen into a DType
    data[i] = dis(gen);
  }
}

template class RNG<double>;
template class RNG<float>;
template class RNG<Point3d>;
template class RNG<Vec3d>;